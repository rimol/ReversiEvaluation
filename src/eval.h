#pragma once

#include <filesystem>
#include <string>
#include "bitboard.h"

// maskStr: (改行+8文字)*8+改行+NULL文字=74文字
struct FeatureMask {
    Bitboard mask;
    constexpr FeatureMask(const char (&maskStr)[74]) : mask() {
        Bitboard j = 1ULL;
        for (int i = 72; i >= 1; --i) {
            if (i % 9 == 0) continue;
            mask |= maskStr[i] == '.' ? 0ULL : j;
            j <<= 1;
        }
    }
};

/*
  ver0                 ver7
    A  B  C  D  E  F  G  H
1  63 62 61 60 59 58 57 56 hor0
2  55 54 53 52 51 50 49 48
3  47 46 45 44 43 42 41 40
4  39 38 37 36 35 34 33 32
5  31 30 29 28 27 26 25 24
6  23 22 21 20 19 18 17 16
7  15 14 13 12 11 10 09 08
8  07 06 05 04 03 02 01 00 hor7

*/

/*
cor0                              cor1
    A  B  C  D  E  F  G  H
1  63 62 61         60 59        58 57 56
2  55 54 53         52 51        50 49 48
3  47 46         45 44 43 42        41 40

4        39 38 37 36 35 34 33 32
5        31 30 29 28 27 26 25 24

6  23 22         21 20 19 18        17 16
7  15 14 13         12 11        10 09 08
8  07 06 05         04 03        02 01 00
cor2                              cor3

*/

constexpr FeatureMask features[] = {
R"(
########
........
........
........
........
........
........
........
)",

R"(
........
########
........
........
........
........
........
........
)",

R"(
........
........
########
........
........
........
........
........
)",

R"(
........
........
........
########
........
........
........
........
)",

R"(
........
........
........
........
########
........
........
........
)",

R"(
........
........
........
........
########
........
........
........
)",

R"(
........
........
........
........
........
........
########
........
)",

R"(
........
........
........
........
........
........
........
########
)",

R"(
#.......
#.......
#.......
#.......
#.......
#.......
#.......
#.......
)",

R"(
.#......
.#......
.#......
.#......
.#......
.#......
.#......
.#......
)",

R"(
..#.....
..#.....
..#.....
..#.....
..#.....
..#.....
..#.....
..#.....
)",

R"(
...#....
...#....
...#....
...#....
...#....
...#....
...#....
...#....
)",

R"(
....#...
....#...
....#...
....#...
....#...
....#...
....#...
....#...
)",

R"(
.....#..
.....#..
.....#..
.....#..
.....#..
.....#..
.....#..
.....#..
)",

R"(
......#.
......#.
......#.
......#.
......#.
......#.
......#.
......#.
)",

R"(
.......#
.......#
.......#
.......#
.......#
.......#
.......#
.......#
)",

R"(
###.....
###.....
##......
........
........
........
........
........
)",

R"(
.....###
.....###
......##
........
........
........
........
........
)",

R"(
........
........
........
........
........
##......
###.....
###.....
)",

R"(
........
........
........
........
........
......##
.....###
.....###
)",

R"(
#.......
.#......
..#.....
...#....
....#...
.....#..
......#.
.......#
)",

R"(
.#......
..#.....
...#....
....#...
.....#..
......#.
.......#
#.......
)",

R"(
..#.....
...#....
....#...
.....#..
......#.
.......#
#.......
.#......
)",

R"(
...#....
....#...
.....#..
......#.
.......#
#.......
.#......
..#.....
)",

R"(
....#...
.....#..
......#.
.......#
#.......
.#......
..#.....
...#....
)",

R"(
.....#..
......#.
.......#
#.......
.#......
..#.....
...#....
....#...
)",

R"(
......#.
.......#
#.......
.#......
..#.....
...#....
....#...
.....#..
)",

R"(
.......#
#.......
.#......
..#.....
...#....
....#...
.....#..
......#.
)",

R"(
.......#
......#.
.....#..
....#...
...#....
..#.....
.#......
#.......
)",

R"(
......#.
.....#..
....#...
...#....
..#.....
.#......
#.......
.......#
)",

R"(
.....#..
....#...
...#....
..#.....
.#......
#.......
.......#
......#.
)",

R"(
....#...
...#....
..#.....
.#......
#.......
.......#
......#.
.....#..
)",

R"(
...#....
..#.....
.#......
#.......
.......#
......#.
.....#..
....#...
)",

R"(
..#.....
.#......
#.......
.......#
......#.
.....#..
....#...
...#....
)",

R"(
.#......
#.......
.......#
......#.
.....#..
....#...
...#....
..#.....
)",

R"(
#.......
.......#
......#.
.....#..
....#...
...#....
..#.....
.#......
)",

R"(
........
........
..#..#..
...##...
...##...
..#..#..
........
........
)",

R"(
........
........
...##...
..#..#..
..#..#..
...##...
........
........
)",

/*
R"(
........
........
........
........
........
........
........
........
)",
*/

};

constexpr int FeatureNum = sizeof(features) / sizeof(Bitboard);

// abcdef...(2) -> abcdef...(3)
struct Base3Conversion {
    int table[1 << 8];

    constexpr Base3Conversion() : table() {
        for (int i = 0; i < (1 << 8); ++i) {
            int d = 1;
            for (int j = 0; j < 8; ++j) {
                if (i >> j & 1) table[i] += d;
                d *= 3;
            }
        }
    }
};

constexpr auto ToBase3 = Base3Conversion();

// 下位8ビットの表す盤面を3進数での表現に変換
// 空=0, 黒=1, 白=2;
// テーブル最高。
inline int convert(Bitboard b, Bitboard w) {
    // 3進数では桁かぶりがないので足し算できる。
    return ToBase3.table[b & 0xff] + (ToBase3.table[w & 0xff] << 1);
}

inline int extract(Bitboard p, Bitboard o, int f) {
    return convert(pext(p, features[f].mask), pext(o, features[f].mask));
}

void loadEvalValues(std::filesystem::path evalValuesFolderPath);
double evaluate(Bitboard p, Bitboard o);